/* This file is derived from information found at:                                     */
/* https://blogs.msdn.microsoft.com/lucian/2010/04/19/vb-and-c-grammar-for-vs2010/     */
/* https://bottlecaps.de/convert/                                                      */
/* https://menduz.com/ebnf-highlighter/                                                */
/* https://github.com/dotnet/vblang/tree/master/spec                                   */
 
start ::= Program

Format ::= LogicalLine*
Program ::= OptionStatement? (Statement | MethodDeclaration | ClassDeclaration)*


/* 13.1 Lexical Grammar */

LogicalLine ::= LogicalLineElement* Comment? LineTerminator
LogicalLineElement ::= LineContinuation | WS | Token
Token ::= Identifier | Keyword | Literal | Separator | Operator

/* 13.1.1 Characters and Lines */

Character ::= [^#x0d#x0a] {fragment=true}
LineTerminator ::= [#x0d] [#x0a] | [#x0d] | [#x0a]
LineContinuation ::= WS* '_' WS* LineTerminator
Comma ::= ',' LineTerminator?
Period ::= '.' LineTerminator?
OpenParenthesis ::= '(' LineTerminator?
CloseParenthesis ::= LineTerminator? ')'
Equals ::= '=' LineTerminator?
WS ::= [#x09] | [#x20]
Comment ::= CommentMarker Character*
CommentMarker ::= SingleQuoteCharacter | 'REM' {fragment=true}
SingleQuoteCharacter ::= "'" {fragment=true}

/* 13.1.2 Identifiers */

Identifier ::= NonEscapedIdentifier 
NonEscapedIdentifier ::= !Keyword IdentifierName {fragment=true}
IdentifierName ::= IdentifierStart IdentifierCharacter* {fragment=true}
IdentifierStart ::= AlphaCharacter | UnderscoreCharacter IdentifierCharacter {fragment=true}
IdentifierCharacter ::= UnderscoreCharacter | AlphaCharacter | NumericCharacter {fragment=true}
AlphaCharacter ::= [A-Za-z] {fragment=true}
NumericCharacter ::= [0-9] {fragment=true}
UnderscoreCharacter ::= '_' {fragment=true}
IdentifierOrKeyword ::= Identifier | Keyword

/* 13.1.3 Keywords */

Keywords ::= 'And' | 'ByVal' | 'ByRef' | 'Case' | 'Call' | 'Class' | 'Const' | 'Default' | 'Dim' | 'Do' | 'Each' | 'ElseIf' | 'Else' | 'Empty' | 'End' | 'Erase' | 'Error' | 'Eqv' | 'Exit' | 'Explicit' | 'False' | 'For' | 'Function' | 'Get' | 'GoTo' | 'If' | 'In' | 'Is' | 'Let' | 'Loop' | 'Mod' | 'New' | 'Next' | 'Nothing' | 'Not' | 'Null' | 'On' | 'Option' | 'Or' | 'Preserve' | 'Private' | 'Property' | 'Public' | 'ReDim' | 'Resume' | 'Select' | 'Set' | 'Step' | 'Sub' | 'Then' | 'To' | 'True' | 'Until' | 'While' | 'WEnd' | 'With' | 'Xor' {fragment=true}
Keyword ::= Keywords ![A-Za-z0-9_]

/* 13.1.4 Literals */

Literal ::= BooleanLiteral | FloatingPointLiteral | IntegerLiteral | StringLiteral | DateLiteral | NothingLiteral | EmptyLiteral | NullLiteral
BooleanLiteral ::= 'True' | 'False'
IntegerLiteral ::= IntegralLiteralValue
IntegralLiteralValue ::= IntLiteral | HexLiteral | OctalLiteral {fragment=true}
IntLiteral ::= Digit+
HexLiteral ::= '&' 'H' HexDigit+
OctalLiteral ::= '&' 'O' OctalDigit+
Digit ::= [0-9] {fragment=true}
HexDigit ::= [0-9A-Fa-f] {fragment=true}
OctalDigit ::= [0-7] {fragment=true}
FloatingPointLiteral ::= FloatingPointLiteralValue
FloatingPointLiteralValue ::= IntLiteral ( '.' IntLiteral Exponent? | Exponent ) | '.' IntLiteral Exponent?
Exponent ::= 'E' Sign? IntLiteral
Sign ::= '+' | '-'
StringLiteral ::= DoubleQuoteCharacter StringCharacter* DoubleQuoteCharacter 
DoubleQuoteCharacter ::= '"' {fragment=true}
StringCharacter ::= [^"] | DoubleQuoteCharacter DoubleQuoteCharacter {fragment=true}
DateLiteral ::= '#' WS* DateOrTime WS* '#'
DateOrTime ::= DateValue ( WS+ TimeValue )? | TimeValue
DateValue ::= MonthValue ( '/' DayValue '/' | '-' DayValue '-' ) YearValue
TimeValue ::= HourValue ( ':' MinuteValue ( ':' SecondValue )? WS* AMPM? | WS* AMPM )
MonthValue ::= IntLiteral
DayValue ::= IntLiteral
YearValue ::= IntLiteral
HourValue ::= IntLiteral
MinuteValue ::= IntLiteral
SecondValue ::= IntLiteral
AMPM ::= 'AM' | 'PM'
NothingLiteral ::= 'Nothing'
EmptyLiteral ::= 'Empty'
NullLiteral ::= 'Null'
Separator ::= '(' | ')' | '{' | '}' | '!' | '#' | ',' | '.' | ':' | '?'
Operator ::= '&' | '*' | '+' | '-' | '/' | '\\' | '^' | '<' | '=' | '>'
ElseIf ::= 'ElseIf' | 'Else' WS 'If'

/* 13.3 Syntactic Grammar */

AccessModifier ::= 'Public' WS 'Default' | 'Public' | 'Private'

/* 13.3.2 Source Files and Namespaces */

StatementTerminator ::= LineTerminator | ':'
StatementTerminatorInline ::= ':'

OptionStatement ::= OptionExplicitStatement
OptionExplicitStatement ::= 'Option' WS 'Explicit' OnOff? StatementTerminator 
OnOff ::= 'On' | 'Off'

/* 13.3.3 Types */

IdentifierModifiers ::= ArrayNameModifier?

ClassDeclaration ::= 'Class' WS Identifier StatementTerminator ClassMemberDeclaration* 'End' WS 'Class' StatementTerminator

ClassMemberDeclaration ::= VariableMemberDeclaration | ConstantMemberDeclaration | ConstructorMemberDeclaration | MethodMemberDeclaration | PropertyMemberDeclaration

ArrayTypeModifiers ::= ArrayTypeModifier+
ArrayTypeModifier ::= OpenParenthesis RankList? CloseParenthesis
RankList ::= Comma*
ArrayNameModifier ::= ArrayTypeModifiers | ArraySizeInitializationModifier

/* 13.3.4 Type Members */

MethodMemberDeclaration ::= MethodDeclaration
MethodDeclaration ::= SubDeclaration | FunctionDeclaration
SubSignature ::= 'Sub' WS Identifier ( OpenParenthesis ParameterList? CloseParenthesis )? 
FunctionSignature ::= 'Function' WS Identifier ( OpenParenthesis ParameterList? CloseParenthesis )? 
SubDeclaration ::= (AccessModifier WS)? SubSignature (WS | StatementTerminator) Block? 'End' WS 'Sub' StatementTerminator 
FunctionDeclaration ::= (AccessModifier WS)? FunctionSignature (WS | StatementTerminator) Block? 'End' WS 'Function' StatementTerminator 

ParameterList ::= Parameter ( Comma Parameter )*
Parameter ::= (ParameterModifier WS)? ParameterIdentifier ( Equals ConstantExpression )? 
ParameterModifier ::= 'ByVal' | 'ByRef'
ParameterIdentifier ::= Identifier

ConstructorMemberDeclaration ::= (ConstructorModifier? WS) 'Sub' WS 'Class_Initialize' ( OpenParenthesis CloseParenthesis )? StatementTerminator Block? 'End' WS 'Sub' StatementTerminator
ConstructorModifier ::= AccessModifier

ConstantMemberDeclaration ::= (ConstantModifier WS)? 'Const' WS ConstantDeclarators StatementTerminator
ConstantMemberDeclarationInline ::= (ConstantModifier WS)? 'Const' WS ConstantDeclarators
ConstantModifier ::= AccessModifier
ConstantDeclarators ::= ConstantDeclarator ( Comma ConstantDeclarator )*
ConstantDeclarator ::= Identifier Equals ConstantExpression

VariableMemberDeclaration ::= VariableModifier WS VariableDeclarators StatementTerminator
VariableMemberDeclarationInline ::= VariableModifier WS VariableDeclarators
VariableModifier ::= AccessModifier | 'Dim'
VariableDeclarators ::= VariableDeclarator ( Comma VariableDeclarator )*
VariableDeclarator ::= VariableIdentifiers
VariableIdentifiers ::= VariableIdentifier ( Comma VariableIdentifier )*
VariableIdentifier ::= Identifier IdentifierModifiers?

ArraySizeInitializationModifier ::= OpenParenthesis BoundList CloseParenthesis
BoundList ::= Bound ( Comma Bound )*
Bound ::= Expression

PropertyMemberDeclaration ::= RegularPropertyMemberDeclaration
RegularPropertyMemberDeclaration ::= PropertyModifier WS 'Property' WS PropertyAccessorDeclaration 'End' WS 'Property' StatementTerminator
AutoPropertyModifier ::= AccessModifier
PropertyModifier ::= AutoPropertyModifier
PropertyAccessorDeclaration ::= PropertyGetDeclaration | PropertyLetDeclaration | PropertySetDeclaration
PropertyGetDeclaration ::= 'Get' WS Identifier ( OpenParenthesis ParameterList? CloseParenthesis )? StatementTerminator Block?
PropertyLetDeclaration ::= 'Let' WS Identifier ( OpenParenthesis ParameterList? CloseParenthesis )? StatementTerminator Block?
PropertySetDeclaration ::= 'Set' WS Identifier ( OpenParenthesis ParameterList? CloseParenthesis )? StatementTerminator Block?

/* 13.3.5 Statements */

Statement ::= VariableMemberDeclaration | ConstantMemberDeclaration | WithStatement | AssignmentStatement | InvocationStatement | ArrayHandlingStatement | LoopStatement | ConditionalStatement | ErrorHandlingStatement | BranchStatement
StatementInline ::= VariableMemberDeclarationInline | ConstantMemberDeclarationInline | AssignmentStatementInline | InvocationStatementInline | ArrayHandlingStatementInline | BranchStatementInline | LoopStatementInline | ConditionalStatementInline

Block ::= Statements* (StatementInline WS)?
Statements ::= Statement? ( ':' Statement? )*
StatementsInline ::= StatementInline? ( ':' StatementInline? )*

WithStatement ::= 'With' WS Expression StatementTerminator Block? 'End' WS 'With' StatementTerminator
AssignmentStatement ::= SetAssignmentStatement | RegularAssignmentStatement
AssignmentStatementInline ::= SetAssignmentStatementInline | RegularAssignmentStatementInline
RegularAssignmentStatement ::= SubExpression Equals Expression StatementTerminator 
RegularAssignmentStatementInline ::= SubExpression Equals Expression 
SetAssignmentStatement ::= 'Set' WS SubExpression Equals (NewExpression (WS NothingLiteral)?| Expression) StatementTerminator 
SetAssignmentStatementInline ::= 'Set' WS SubExpression Equals (NewExpression (WS NothingLiteral)?| Expression)
NewExpression ::= 'New' WS Identifier
InvocationStatement ::= ('Call' WS)? InvocationExpression StatementTerminator
InvocationStatementInline ::= ('Call' WS)? InvocationExpression
ConditionalStatement ::= IfStatement | SelectStatement
ConditionalStatementInline ::= IfStatementInline
IfStatement ::= BlockIfStatement | LineIfThenStatement
IfStatementInline ::= LineIfThenStatement
BlockIfStatement ::= 'If' WS BooleanExpression (WS 'Then')? StatementTerminator Block? ElseIfStatement* ElseStatement? 'End' WS 'If' StatementTerminator
ElseIfStatement ::= ElseIf WS BooleanExpression (WS 'Then')? StatementTerminator Block?
ElseStatement ::= 'Else' StatementTerminator Block?
LineIfThenStatement ::= 'If' WS BooleanExpression WS 'Then' WS StatementsInline (WS? 'Else' WS StatementsInline )? (WS? 'End' WS 'If')? LineTerminator?
SelectStatement ::= 'Select' WS 'Case' WS Expression StatementTerminator CaseStatement* CaseElseStatement? 'End' WS 'Select' StatementTerminator 
CaseStatement ::= 'Case' WS CaseClauses WS? StatementTerminator? Block? 
CaseClauses ::= CaseClause ( Comma CaseClause )* 
CaseClause ::= Expression
CaseElseStatement ::= 'Case' WS 'Else' WS? StatementTerminator? Block? 
LoopStatement ::= WhileStatement | DoLoopStatement | ForStatement | ForEachStatement
LoopStatementInline ::= ForStatementInline
WhileStatement ::= 'While' WS BooleanExpression StatementTerminator Block? 'WEnd' StatementTerminator 
DoLoopStatement ::= DoTopLoopStatement | DoBottomLoopStatement
DoTopLoopStatement ::= 'Do' ( WS WhileOrUntil WS BooleanExpression )? StatementTerminator Block? 'Loop' StatementTerminator 
DoBottomLoopStatement ::= 'Do' StatementTerminator Block? 'Loop' WS WhileOrUntil WS BooleanExpression StatementTerminator 
WhileOrUntil ::= 'While' | 'Until'
ForStatement ::= 'For' WS LoopControlVariable Equals Expression WS 'To' WS Expression ( WS 'Step' WS Expression )? StatementTerminator Block? 'Next' StatementTerminator 
ForStatementInline ::= 'For' WS LoopControlVariable Equals Expression WS 'To' WS Expression ( WS 'Step' WS Expression )? StatementTerminatorInline StatementsInline 'Next' 
LoopControlVariable ::= Identifier | Expression 
ForEachStatement ::= 'For' WS 'Each' WS LoopControlVariable WS 'In' WS? LineTerminator? Expression StatementTerminator Block? 'Next' StatementTerminator 
ErrorHandlingStatement ::= UnstructuredErrorStatement
UnstructuredErrorStatement ::= OnErrorStatement
OnErrorStatement ::= 'On' WS 'Error' WS ErrorClause StatementTerminator 
ErrorClause ::= 'GoTo' WS '0' | 'Resume' WS 'Next' 
BranchStatement ::= ExitStatement
BranchStatementInline ::= ExitStatementInline
ExitStatement ::= 'Exit' WS ExitKind StatementTerminator
ExitStatementInline ::= 'Exit' WS ExitKind 
ExitKind ::= 'Do' | 'For'  | 'Sub' | 'Function' | 'Property'

ArrayHandlingStatement ::= RedimStatement | EraseStatement
ArrayHandlingStatementInline ::= RedimStatementInline | EraseStatementInline
RedimStatement ::= 'ReDim' (WS 'Preserve')? WS RedimClauses StatementTerminator 
RedimStatementInline ::= 'ReDim' (WS 'Preserve')? WS RedimClauses
RedimClauses ::= RedimClause ( Comma RedimClause )*
RedimClause  ::= Identifier ArraySizeInitializationModifier
EraseStatement ::= 'Erase' WS EraseExpressions StatementTerminator
EraseStatementInline ::= 'Erase' WS EraseExpressions
EraseExpressions ::= Expression ( Comma Expression )*

/* 13.3.6 Expressions */

Expression ::= LogicalOperatorExpression
ConstantExpression ::= Expression
SimpleExpression ::= LiteralExpression | ParenthesizedExpression | SimpleNameExpression
LiteralExpression ::= Literal
ParenthesizedExpression ::= OpenParenthesis Expression CloseParenthesis
SimpleNameExpression ::= Identifier
MemberAccessExpression ::= Period IdentifierOrKeyword

InvocationExpression ::= (SimpleNameExpression | MemberAccessExpression) InvocationExpression? (EmptyArgument* | ArgumentList*)? 
EmptyArgument ::= OpenParenthesis CloseParenthesis
ArgumentList ::= WS? Comma? Expression (Comma ArgumentList?)*

LogicalOperatorExpression ::= RelationalOperatorExpression (WS ('And' | 'Or' | 'Xor' | 'Eqv') WS? LineTerminator? RelationalOperatorExpression)*  
RelationalOperatorExpression ::= AdditionOperatorExpression (( '=' | '<' ( '>' | '=' )? | '>' '='?) LineTerminator? AdditionOperatorExpression)*
AdditionOperatorExpression ::= ModuloOperatorExpression (('+' | '-') LineTerminator? ModuloOperatorExpression)*
ModuloOperatorExpression ::= IntegerDivisionOperatorExpression (WS 'Mod' WS? LineTerminator? IntegerDivisionOperatorExpression)* 
IntegerDivisionOperatorExpression ::= MultiplicationOperatorExpression ('\\' LineTerminator? MultiplicationOperatorExpression)*
MultiplicationOperatorExpression ::= ExponentOperatorExpression (('*' | '/') LineTerminator? ExponentOperatorExpression)*
ExponentOperatorExpression ::= ConcatenationOperatorExpression ('^' LineTerminator? ConcatenationOperatorExpression)* 
ConcatenationOperatorExpression ::= TypeExpression ('&' LineTerminator? TypeExpression)*
TypeExpression ::= Value (WS 'Is' WS LineTerminator? Value)*
LogicalNotOperatorExpression ::= 'Not' WS Value 
UnaryExpression ::= ('+' | '-') Value 

SubExpression ::= (SimpleNameExpression | MemberAccessExpression) (OpenParenthesis ArgumentList? CloseParenthesis)* SubExpression? 

Value ::= LogicalNotOperatorExpression | UnaryExpression | SubExpression | SimpleExpression

BooleanExpression ::= Expression
